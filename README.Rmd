---
output:
  github_document
---

## `emoncmsr`: R interface to the [emonCMS](https://github.com/emoncms/emoncms) API


This package provides the tools to create, delete, and manage inputs and feeds 
in the open source energy, temperature and environmental monitoring sytem from 
[OpenEnergyMonitor](https://openenergymonitor.org/).

emonCMS has two flavors, a self-hosted version and a hosted solution at 
[emoncms.org](https://emoncms.org). The two APIs are similar but differ in a 
number of areas. This package only supports the self-hosted flavor, though 
there are several unsupported functions for the hosted version.

This package takes a slightly opinionated view towards the API, returning 
normalized values from many of the API calls. The native API has several non-
standard and inconsistent responses to both success and failure. `emoncmsr` 
provides an interface consistent with data analysis and a tidy pipeline.

## Installation
```{r eval=FALSE}
devtools::install_github("davidski/emoncmsr")
```

## Usage

emoncmsr requires two environment variables to locate the emoncms host and the
proper API key for authentication. These can be set globally (e.g. via 
`.bashrc`, the Windows control panel, or other OS-specific mechanism) or you 
can place them in your `~.Renviron` file for a portable solution.

Environment variables used:

  * EMONCMS_URI - Full URL (w/final slash) to API endpoint
  * EMONCMS_API_KEY - API key value (read or write) to API
    
## Applications

Simulating a beverage sensor that monitors the level of coffee, tea, and 
water available. First, we'll list the inputs currently configured.

```{r listing_inputs}
library(emoncmsr)
suppressPackageStartupMessages(library(tidyverse))  # use the tidyverse

# Inputs
list_inputs()
```

Now we'll create some simulated data, post it to emonCMS as inputs using a
node identifier of `emoncmsr`, read back the value of the coffee level we just 
posted, store the ID of this new coffee input for future use, and set a useful 
description for the new input. Whew! Let's get to it!

```{r posting_to_inputs}
# create some beverage data
dat <- list(coffee = 42, tea = 6, water = 42)
post_data_to_input(dat)
list_inputs() %>% filter(nodeid == "emoncmsr", name == "coffee")
# store the id of the new input
inputid <- list_inputs() %>% 
  filter(nodeid == "emoncmsr", name == "coffee") %>% 
  pull(id)
inputid

# set a friendly description for our new input
set_input_field(inputid, "description", "cups of coffee remaining in pot")
list_inputs() %>% filter(id == inputid)
```

That wasn't so bad! 

While we're now accepting levels of coffee, tea, and water in emonCMS, those 
values aren't being stored or processed in any way. We'd like to monitor the 
levels of coffee over time. We need to create a feed, then configure the 
coffee input to send its data to that feed.

```{r creating_the_coffee_feed}

# Create a feed for the coffee level
feed_response <- create_feed("coffeelevel", "emoncmsr")
feed_response

# Show that the feed exists
list_feeds() %>% filter(id == feed_response$feedid)

# Hook up the coffee monitor to the feed
set_input_process(inputid, paste(1, feed_response$feedid, sep = ":"))
get_input_processes(inputid)
```

Now that we have our feed set up, let's send some updated beverage level sensor 
data. We'll first send a single timepoint set of values, then demonstrate using 
the bulk data inteface to send multiple timeponts of data. After sending the 
readings we'll read the current values from the feed to show that things are 
flowing correctly.

```{r post_data_to_inputs}
# Post a single set of readings to all three new inputs
dat <- list(coffee = 86, tea = 100, water = 4)
post_data_to_input(dat)

# We can also use the bulk data input format for sending a dataframe 
# worth of data, all at different offsets to an optional timestamp
dat <- tibble::tribble(~offset, ~nodeid, ~value,
                       -100, "emoncmsr", list(coffee = 100),
                       -50, "emoncmsr", list(tea = 50),
                       -10, "emoncmsr", list(water = 10))
post_bulk_data_to_input(dat)

# show the values we just posted appeared in the inputs
list_inputs() %>% filter(nodeid == "emoncmsr")

# we can also post with a specific reference time
reference_time <- lubridate::as_datetime("2017-03-27 01:30:00") %>% as.integer()
post_bulk_data_to_input(dat, reference_time)

# show the logged input made it to our new feed
get_feed_values(feed_response$feedid)
```

Beverage monitoring systems [are GO](https://en.wikipedia.org/wiki/Thunderbirds_Are_Go)! 
Let's pull a set of data from a feed and plot that data over time, adding 
a smoothed curve for grins.

```{r plotting_feed_data}
dat <- get_feed_data(1)
gg <- ggplot(dat, aes(x = date, y = value)) + 
  geom_line() + geom_smooth(method = 'loess') +
  labs(title = "Power Usage", 
       subtitle = "Seven day historical with smoothed overlay",
       caption = "Demonstration plot for emoncmsr",
       y = "Watts", 
       x = NULL) +
  scale_y_continuous(labels = scales::comma) +
  theme_minimal()
gg
```

Finally, clean up the test inputs and feeds we created.

```{r clean_up}
list_feeds() %>% filter(tag == "emoncmsr") %>% pull(id) %>% 
  map(~ delete_feed(.x))
list_inputs() %>% filter(nodeid == "emoncmsr") %>% pull(id) %>% 
  map(~ delete_input(.x))
```

## Test results

```{r}
library(emoncmsr)
library(testthat)

date()

test_dir("tests/")
```

# Contributing

This project is governed by a [Code of Conduct](./CODE_OF_CONDUCT.md). By 
participating in this project you agree to abide by these terms.

# License

The [MIT License](LICENSE) applies.
